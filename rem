#!/usr/bin/env python3
"""
REM Command CLI - Unified interface for REM + OpenClaw services

Usage:
    rem llm <prompt>              - Generate text using local LLM
    rem llm-chat <message>        - Chat with LLM (uses history)
    rem tts <text>                - Generate speech from text
    rem asr <audio_file>          - Transcribe audio
    rem voice <mode>              - Start voice wake/listen (listen, wake_word, always_on)
    rem openclaw <command> [args] - Run OpenClaw commands
    rem health                    - Check service health
    rem help                      - Show this help
"""

import sys
import asyncio
import json
import logging
from pathlib import Path
from typing import Optional, List

# Add server directory to path for imports
sys.path.insert(0, str(Path(__file__).parent / "server"))

from rem_openclaw_adapter import get_adapter, RemService

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class RemCLI:
    """Command-line interface for REM services."""

    def __init__(self):
        self.adapter = get_adapter()

    async def llm_generate(self, args: List[str]) -> int:
        """Generate text using LLM."""
        if not args:
            print("Error: Missing prompt")
            return 1

        prompt = " ".join(args)
        print(f"üß† Generating from prompt: {prompt}")
        
        result = await self.adapter.call_service(
            RemService.LLM_GENERATE,
            {"prompt": prompt}
        )

        if result["success"]:
            print(f"\n‚úÖ Response:\n{result['result']['text']}\n")
            return 0
        else:
            print(f"\n‚ùå Error: {result['error']}\n")
            return 1

    async def llm_chat(self, args: List[str]) -> int:
        """Chat with LLM."""
        if not args:
            print("Error: Missing message")
            return 1

        user_input = " ".join(args)
        print(f"üí¨ Chat: {user_input}")
        
        result = await self.adapter.call_service(
            RemService.LLM_CHAT,
            {"input": user_input}
        )

        if result["success"]:
            print(f"\n‚úÖ REM:\n{result['result']['response']}\n")
            return 0
        else:
            print(f"\n‚ùå Error: {result['error']}\n")
            return 1

    async def tts_generate(self, args: List[str]) -> int:
        """Generate speech."""
        if not args:
            print("Error: Missing text")
            return 1

        text = " ".join(args)
        print(f"üîä Generating speech: {text}")
        
        result = await self.adapter.call_service(
            RemService.TTS_GENERATE,
            {"text": text}
        )

        if result["success"]:
            audio_file = result['result']['audio_path']
            print(f"\n‚úÖ Audio generated: {audio_file}\n")
            return 0
        else:
            print(f"\n‚ùå Error: {result['error']}\n")
            return 1

    async def asr_transcribe(self, args: List[str]) -> int:
        """Transcribe audio."""
        if not args:
            print("Error: Missing audio file path")
            return 1

        audio_file = args[0]
        print(f"üé§ Transcribing: {audio_file}")
        
        result = await self.adapter.call_service(
            RemService.ASR_TRANSCRIBE,
            {"audio_file": audio_file}
        )

        if result["success"]:
            text = result['result']['text']
            print(f"\n‚úÖ Transcription:\n{text}\n")
            return 0
        else:
            print(f"\n‚ùå Error: {result['error']}\n")
            return 1

    async def voice_wake(self, args: List[str]) -> int:
        """Start voice wake/listen."""
        mode = args[0] if args else "listen"
        if mode not in ["listen", "wake_word", "always_on"]:
            print(f"Error: Invalid mode '{mode}'. Choose: listen, wake_word, always_on")
            return 1

        print(f"üéß Starting voice {mode} mode...")
        
        result = await self.adapter.call_service(
            RemService.VOICE_WAKE,
            {"mode": mode}
        )

        if result["success"]:
            print(f"\n‚úÖ {result['result']['message']}\n")
            return 0
        else:
            print(f"\n‚ùå Error: {result['error']}\n")
            return 1

    async def health_check(self, args: List[str]) -> int:
        """Check service health."""
        print("üè• Checking service health...")
        
        result = await self.adapter.call_service(
            RemService.HEALTH_CHECK,
            {}
        )

        if result["success"]:
            healthy = result['result']['healthy']
            services = result['result']['services']
            
            print(f"\n{'‚úÖ' if healthy else '‚ö†Ô∏è'} Overall: {'Healthy' if healthy else 'Unhealthy'}\n")
            for service, status in services.items():
                symbol = "‚úÖ" if status else "‚ùå"
                print(f"{symbol} {service.upper()}: {'Running' if status else 'Down'}")
            print()
            return 0 if healthy else 1
        else:
            print(f"\n‚ùå Error: {result['error']}\n")
            return 1

    async def openclaw_command(self, args: List[str]) -> int:
        """Run OpenClaw commands."""
        if not args:
            print("Error: Missing OpenClaw command")
            print("Use: rem openclaw <openclaw-command>")
            return 1

        import subprocess
        
        # Find openclaw executable
        openclaw_path = Path(__file__).parent.parent / "openclaw" / "openclaw.mjs"
        if not openclaw_path.exists():
            print(f"Error: OpenClaw not found at {openclaw_path}")
            return 1

        print(f"üîß Running OpenClaw: {' '.join(args)}")
        
        try:
            # Run openclaw with Node
            cmd = ["node", str(openclaw_path)] + args
            result = subprocess.run(cmd, cwd=str(openclaw_path.parent))
            return result.returncode
        except Exception as e:
            print(f"‚ùå Failed to run OpenClaw: {e}")
            return 1

    async def show_help(self) -> int:
        """Show help message."""
        print(__doc__)
        return 0

    async def show_manifest(self, args: List[str]) -> int:
        """Show OpenClaw skill manifest."""
        manifest = self.adapter.get_skill_manifest()
        print(json.dumps(manifest, indent=2))
        return 0

    async def run(self, args: List[str]) -> int:
        """Main CLI entry point."""
        if not args:
            await self.show_help()
            return 0

        command = args[0]
        command_args = args[1:]

        try:
            if command == "llm" and len(args) > 1:
                if args[1] == "chat":
                    return await self.llm_chat(args[2:])
                else:
                    return await self.llm_generate(command_args)
            elif command == "llm-chat":
                return await self.llm_chat(command_args)
            elif command == "tts":
                return await self.tts_generate(command_args)
            elif command == "asr":
                return await self.asr_transcribe(command_args)
            elif command == "voice":
                return await self.voice_wake(command_args)
            elif command == "openclaw":
                return await self.openclaw_command(command_args)
            elif command == "health":
                return await self.health_check(command_args)
            elif command == "manifest":
                return await self.show_manifest(command_args)
            elif command in ["help", "-h", "--help"]:
                return await self.show_help()
            else:
                print(f"Unknown command: {command}")
                await self.show_help()
                return 1
        except KeyboardInterrupt:
            print("\n\nInterrupted by user")
            return 130
        except Exception as e:
            logger.exception(f"Command failed: {e}")
            print(f"\n‚ùå Error: {e}\n")
            return 1


async def main():
    """Script entry point."""
    cli = RemCLI()
    exit_code = await cli.run(sys.argv[1:])
    sys.exit(exit_code)


if __name__ == "__main__":
    asyncio.run(main())
